name: PromptExpert v2

on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  process-expert-command:
    if: github.event.issue.pull_request && contains(github.event.comment.body, '@promptexpert')
    runs-on: ubuntu-latest
    steps:
      - name: Parse command
        id: parse
        run: |
          COMMENT='${{ github.event.comment.body }}'
          
          # Extract expert name and instructions
          # Format: @promptexpert <expert> <instructions...>
          if [[ "$COMMENT" =~ @promptexpert[[:space:]]+([a-zA-Z-]+)[[:space:]]+(.*) ]]; then
            EXPERT="${BASH_REMATCH[1]}"
            INSTRUCTIONS="${BASH_REMATCH[2]}"
            
            echo "expert=$EXPERT" >> $GITHUB_OUTPUT
            echo "instructions=$INSTRUCTIONS" >> $GITHUB_OUTPUT
            echo "valid=true" >> $GITHUB_OUTPUT
            
            echo "Parsed command:"
            echo "  Expert: $EXPERT"
            echo "  Instructions: $INSTRUCTIONS"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Checkout PR
        if: steps.parse.outputs.valid == 'true'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ format('refs/pull/{0}/head', github.event.issue.number) }}
          fetch-depth: 0  # Get full history
          
      - name: Setup environment
        if: steps.parse.outputs.valid == 'true'
        run: |
          npm init -y
          npm install @anthropic-ai/sdk @octokit/rest
          
      - name: Gather context
        if: steps.parse.outputs.valid == 'true'
        id: context
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get PR details
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // Get PR files
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // Get recent comments
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            // Get commits
            const commits = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // Save context
            const context_data = {
              pr: {
                title: pr.data.title,
                body: pr.data.body,
                state: pr.data.state,
                author: pr.data.user.login,
                created_at: pr.data.created_at,
                updated_at: pr.data.updated_at,
                base_branch: pr.data.base.ref,
                head_branch: pr.data.head.ref
              },
              files: files.data.map(f => ({
                filename: f.filename,
                status: f.status,
                additions: f.additions,
                deletions: f.deletions,
                changes: f.changes,
                patch: f.patch
              })),
              recent_comments: comments.data.slice(-5).map(c => ({
                author: c.user.login,
                body: c.body,
                created_at: c.created_at
              })),
              commits: commits.data.map(c => ({
                sha: c.sha,
                author: c.commit.author.name,
                message: c.commit.message,
                date: c.commit.author.date
              }))
            };
            
            fs.writeFileSync('pr-context.json', JSON.stringify(context_data, null, 2));
            
      - name: Process with expert
        if: steps.parse.outputs.valid == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          EXPERT: ${{ steps.parse.outputs.expert }}
          INSTRUCTIONS: ${{ steps.parse.outputs.instructions }}
          PR_NUMBER: ${{ github.event.issue.number }}
          COMMENT_AUTHOR: ${{ github.event.comment.user.login }}
        run: |
          node << 'SCRIPT'
          const { Anthropic } = require('@anthropic-ai/sdk');
          const { Octokit } = require('@octokit/rest');
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');
          
          async function process() {
            const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            
            // Load expert definition
            let expertContent = '';
            try {
              const expertPath = path.join('.github', 'expert-definitions', `${process.env.EXPERT}-expert.md`);
              expertContent = fs.readFileSync(expertPath, 'utf-8');
            } catch (err) {
              expertContent = `You are a ${process.env.EXPERT} expert.`;
            }
            
            // Load PR context
            const prContext = JSON.parse(fs.readFileSync('pr-context.json', 'utf-8'));
            
            // Read changed files content
            const fileContents = {};
            for (const file of prContext.files) {
              if (file.filename.endsWith('.md') || file.filename.endsWith('.txt')) {
                try {
                  fileContents[file.filename] = fs.readFileSync(file.filename, 'utf-8');
                } catch (err) {
                  console.log(`Could not read ${file.filename}`);
                }
              }
            }
            
            // Call Claude with all context
            const response = await anthropic.messages.create({
              model: 'claude-3-5-sonnet-20241022',
              max_tokens: 4000,
              messages: [{
                role: 'user',
                content: `## YOUR ROLE
You are evaluating git file contents from a pull request. You will act as the expert defined below to review these changes and take appropriate actions.

## EXPERT DEFINITION
${expertContent}

## CONTEXT: GIT PULL REQUEST INFORMATION
You are reviewing changes in a Git pull request. The following data shows what files have been modified, added, or deleted in this PR:

### Pull Request Metadata
${JSON.stringify(prContext.pr, null, 2)}

### Changed Files (Git Diff Patches)
${JSON.stringify(prContext.files, null, 2)}

### Recent PR Comments
${JSON.stringify(prContext.recent_comments, null, 2)}

### Commit History
${JSON.stringify(prContext.commits, null, 2)}

## CURRENT FILE CONTENTS IN THE PR
These are the actual file contents after the changes have been applied:
${JSON.stringify(fileContents, null, 2)}

## USER INSTRUCTIONS
User @${process.env.COMMENT_AUTHOR} has requested you to:
"${process.env.INSTRUCTIONS}"

## YOUR TASK
As the ${process.env.EXPERT} expert, analyze these git file changes and follow the user's instructions. Consider:
1. The nature of the changes (additions, deletions, modifications)
2. The quality and appropriateness of the changes for the ${process.env.EXPERT} domain
3. Any issues or improvements needed
4. The specific instructions from the user

Based on your expert analysis, provide a structured response indicating what actions to take.

## RESPONSE FORMAT
You must respond with a JSON object with this structure:
{
  "analysis": "Your detailed analysis here",
  "actions": [
    {
      "type": "comment",
      "content": "The comment to post on the PR"
    },
    {
      "type": "update_file",
      "filename": "path/to/file.md",
      "content": "New content for the file"
    },
    {
      "type": "close_pr",
      "comment": "Optional comment explaining why"
    },
    {
      "type": "approve_pr",
      "comment": "Optional approval comment"
    }
  ],
  "summary": "Brief summary of what was done"
}

Valid action types: comment, update_file, close_pr, approve_pr, request_changes

Return ONLY the JSON object, no other text.`
              }]
            });
            
            // Parse response
            let result;
            try {
              result = JSON.parse(response.content[0].text);
            } catch (err) {
              console.error('Failed to parse Claude response:', response.content[0].text);
              throw new Error('Invalid response format from Claude');
            }
            
            // Execute actions
            for (const action of result.actions) {
              switch (action.type) {
                case 'comment':
                  await octokit.issues.createComment({
                    owner,
                    repo,
                    issue_number: process.env.PR_NUMBER,
                    body: action.content
                  });
                  break;
                  
                case 'update_file':
                  fs.writeFileSync(action.filename, action.content);
                  execSync(`git add ${action.filename}`);
                  break;
                  
                case 'close_pr':
                  if (action.comment) {
                    await octokit.issues.createComment({
                      owner,
                      repo,
                      issue_number: process.env.PR_NUMBER,
                      body: action.comment
                    });
                  }
                  await octokit.pulls.update({
                    owner,
                    repo,
                    pull_number: process.env.PR_NUMBER,
                    state: 'closed'
                  });
                  break;
                  
                case 'approve_pr':
                  await octokit.pulls.createReview({
                    owner,
                    repo,
                    pull_number: process.env.PR_NUMBER,
                    body: action.comment || 'Approved by PromptExpert',
                    event: 'APPROVE'
                  });
                  break;
                  
                case 'request_changes':
                  await octokit.pulls.createReview({
                    owner,
                    repo,
                    pull_number: process.env.PR_NUMBER,
                    body: action.comment || 'Changes requested by PromptExpert',
                    event: 'REQUEST_CHANGES'
                  });
                  break;
              }
            }
            
            // Commit any file changes
            try {
              execSync('git diff --quiet');
            } catch (err) {
              // There are changes to commit
              execSync('git config user.name "PromptExpert Bot"');
              execSync('git config user.email "promptexpert[bot]@users.noreply.github.com"');
              execSync(`git commit -m "PromptExpert: ${result.summary || 'Updates based on expert analysis'}"`);
              execSync('git push');
            }
          }
          
          process().catch(async err => {
            console.error('Error:', err);
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            await octokit.issues.createComment({
              owner,
              repo,
              issue_number: process.env.PR_NUMBER,
              body: `❌ PromptExpert encountered an error: ${err.message}`
            });
            process.exit(1);
          });
          SCRIPT
          
      - name: Handle invalid command
        if: steps.parse.outputs.valid != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `❌ **Invalid PromptExpert command format**
              
**Expected format:**
\`\`\`
@promptexpert <expert> <instructions>
\`\`\`

**Examples:**
\`\`\`
@promptexpert security analyze this PR for security vulnerabilities
@promptexpert programming review the code quality and suggest improvements
@promptexpert financial check if proper disclaimers are included
\`\`\`

**Available experts:** security, programming, financial, data-analysis, general`
            })